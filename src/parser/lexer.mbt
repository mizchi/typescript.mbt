// TypeScript

///|
// /
pub enum TokenKind {
  // literal
  Number(Double)
  Int(Int)
  Bool(Bool)
  Str(String) // stringliteral
  Regex(String, String) // /pattern/flags
  Ident(String)


  Function
  Class
  Extends
  Var
  Let
  Const
  Return
  If
  Else
  Switch
  Case
  Default
  While
  Do
  For
  Break
  Continue
  Try
  Catch
  Finally
  Throw
  Yield
  Typeof
  Delete

  // type
  NumberType // number
  BooleanType // boolean
  VoidType // void
  IntType // int ()
  StringType // string

  // operator
  Plus // +
  Minus // -
  Star // *
  StarStar // **
  Slash // /
  Percent // %
  Caret // ^
  Amp // &
  Pipe // |
  EqEq // ==
  EqEqEq // ===
  BangEq // !=
  BangEqEq // !==
  Instanceof // instanceof
  Lt // <
  LtLt // <<
  Le // <=
  Gt // >
  GtGt // >>
  GtGtGt // >>>
  Ge // >=
  AmpAmp // &&
  PipePipe // ||
  Bang // !
  Eq // =
  Question // ?
  PlusPlus // ++
  MinusMinus // --
  PlusEq // +=
  MinusEq // -=
  StarEq // *=
  StarStarEq // **=
  SlashEq // /=
  PercentEq // %=
  AmpEq // &=
  PipeEq // |=
  CaretEq // ^=
  LtLtEq // <<=
  GtGtEq // >>=
  GtGtGtEq // >>>=
  Arrow // =>
  Ellipsis // ...


  LParen // (
  RParen // )
  LBrace // {
  RBrace // }
  LBracket // [
  RBracket // ]
  Comma // ,
  Colon // :
  Semicolon // ;
  Dot // .

  // (add)
  New // new
  Interface // interface
  Type // type (type alias)
  Of // of (for...of)
  In // in (for...in)
  Declare // declare (externalimport)
  Null // null


  Eof
} derive(Eq, Show)

///|
// /
pub struct Token {
  kind : TokenKind
  pos : Int // position
} derive(Show)

///|
fn write_codepoint(buf : StringBuilder, code : Int) -> Unit {
  if code < 0 || code > 0x10ffff || (code >= 0xd800 && code <= 0xdfff) {
    buf.write_char('\ufffd')
  } else {
    buf.write_char(code.unsafe_to_char())
  }
}

///|
// /
pub struct Lexer {
  src : String
  mut pos : Int
  mut allow_regex : Bool
} derive(Show)

///|
// / 161( advance )
fn Lexer::read_hex_digit(self : Lexer) -> Int? {
  match self.peek() {
    Some(c) =>
      if c >= '0' && c <= '9' {
        let _ = self.advance()
        Some(c.to_int() - '0'.to_int())
      } else if c >= 'a' && c <= 'f' {
        let _ = self.advance()
        Some(10 + (c.to_int() - 'a'.to_int()))
      } else if c >= 'A' && c <= 'F' {
        let _ = self.advance()
        Some(10 + (c.to_int() - 'A'.to_int()))
      } else {
        None
      }
    None => None
  }
}

///|
// / create
pub fn Lexer::new(src : String) -> Lexer {
  { src, pos: 0, allow_regex: true }
}

///|
// / currentstatementget
fn Lexer::peek(self : Lexer) -> Char? {
  if self.pos >= self.src.length() {
    None
  } else {
    Some(self.src[self.pos].to_int().unsafe_to_char())
  }
}

///|
// / statement
fn Lexer::peek_next(self : Lexer) -> Char? {
  if self.pos + 1 >= self.src.length() {
    None
  } else {
    Some(self.src[self.pos + 1].to_int().unsafe_to_char())
  }
}

///|
// / positionget
fn Lexer::peek_byte(self : Lexer, offset : Int) -> Int? {
  let idx = self.pos + offset
  if idx >= self.src.length() || idx < 0 {
    None
  } else {
    Some(self.src[idx].to_int())
  }
}

///|
// / statement
fn Lexer::advance(self : Lexer) -> Char? {
  let c = self.peek()
  if c is Some(_) {
    self.pos += 1
  }
  c
}

///|
// /
fn Lexer::skip_whitespace(self : Lexer) -> Unit {
  while true {
    match self.peek_byte(0) {
      Some(0x0B) | Some(0x0C) => {
        self.pos += 1
        continue
      }
      Some(0xA0) | Some(0x2028) | Some(0x2029) => {
        self.pos += 1
        continue
      }
      Some(0xC2) if self.peek_byte(1) == Some(0xA0) => {
        self.pos += 2
        continue
      }
      Some(0xE2) if self.peek_byte(1) == Some(0x80) => {
        match self.peek_byte(2) {
          Some(0xA8) | Some(0xA9) => {
            self.pos += 3
            continue
          }
          _ => ()
        }
      }
      Some(0xEF) if self.peek_byte(1) == Some(0xBB) && self.peek_byte(2) == Some(0xBF) => {
        self.pos += 3
        continue
      }
      _ => ()
    }
    match self.peek() {
      Some('#') if self.peek_next() == Some('!') => {
        let _ = self.advance()
        let _ = self.advance()
        while true {
          match self.peek() {
            Some('\n') | None => break
            _ => {
              let _ = self.advance()

            }
          }
        }
      }
      Some(' ') | Some('\t') | Some('\n') | Some('\r') => {
        let _ = self.advance()

      }

      Some('/') =>
        match self.peek_next() {
          Some('/') => {

            let _ = self.advance()
            let _ = self.advance()
            while true {
              match self.peek() {
                Some('\n') | None => break
                _ => {
                  let _ = self.advance()

                }
              }
            }
          }
          Some('*') => {
            // block
            let _ = self.advance()
            let _ = self.advance()
            while true {
              match self.peek() {
                None => break
                Some('*') =>
                  match self.peek_next() {
                    Some('/') => {
                      let _ = self.advance()
                      let _ = self.advance()
                      break
                    }
                    _ => {
                      let _ = self.advance()

                    }
                  }
                _ => {
                  let _ = self.advance()

                }
              }
            }
          }
          _ => break
        }
      _ => break
    }
  }
}

///|
// / literal
fn Lexer::scan_number(self : Lexer) -> TokenKind {
  let start = self.pos
  // Radix-prefixed integers: 0x / 0o / 0b
  if self.peek() == Some('0') {
    match self.peek_next() {
      Some('x') | Some('X') => {
        let _ = self.advance()
        let _ = self.advance()
        let mut value = 0
        let mut has_digit = false
        while true {
          match self.peek() {
            Some('_') => {
              let _ = self.advance()
            }
            Some(c) =>
              match c {
                '0' => {
                  let _ = self.advance()
                  value = value * 16 + 0
                  has_digit = true
                }
                '1' => {
                  let _ = self.advance()
                  value = value * 16 + 1
                  has_digit = true
                }
                '2' => {
                  let _ = self.advance()
                  value = value * 16 + 2
                  has_digit = true
                }
                '3' => {
                  let _ = self.advance()
                  value = value * 16 + 3
                  has_digit = true
                }
                '4' => {
                  let _ = self.advance()
                  value = value * 16 + 4
                  has_digit = true
                }
                '5' => {
                  let _ = self.advance()
                  value = value * 16 + 5
                  has_digit = true
                }
                '6' => {
                  let _ = self.advance()
                  value = value * 16 + 6
                  has_digit = true
                }
                '7' => {
                  let _ = self.advance()
                  value = value * 16 + 7
                  has_digit = true
                }
                '8' => {
                  let _ = self.advance()
                  value = value * 16 + 8
                  has_digit = true
                }
                '9' => {
                  let _ = self.advance()
                  value = value * 16 + 9
                  has_digit = true
                }
                'a' | 'A' => {
                  let _ = self.advance()
                  value = value * 16 + 10
                  has_digit = true
                }
                'b' | 'B' => {
                  let _ = self.advance()
                  value = value * 16 + 11
                  has_digit = true
                }
                'c' | 'C' => {
                  let _ = self.advance()
                  value = value * 16 + 12
                  has_digit = true
                }
                'd' | 'D' => {
                  let _ = self.advance()
                  value = value * 16 + 13
                  has_digit = true
                }
                'e' | 'E' => {
                  let _ = self.advance()
                  value = value * 16 + 14
                  has_digit = true
                }
                'f' | 'F' => {
                  let _ = self.advance()
                  value = value * 16 + 15
                  has_digit = true
                }
                _ => break
              }
            None => break
          }
        }
        if not(has_digit) {
          value = 0
        }
        let mut is_bigint = false
        if self.peek() == Some('n') {
          is_bigint = true
          let _ = self.advance()
        }
        if is_bigint {
          return Number(value.to_double())
        } else {
          return Int(value)
        }
      }
      Some('b') | Some('B') => {
        let _ = self.advance()
        let _ = self.advance()
        let mut value = 0
        let mut has_digit = false
        while true {
          match self.peek() {
            Some('_') => {
              let _ = self.advance()
            }
            Some('0') => {
              let _ = self.advance()
              value = value * 2
              has_digit = true
            }
            Some('1') => {
              let _ = self.advance()
              value = value * 2 + 1
              has_digit = true
            }
            _ => break
          }
        }
        if not(has_digit) {
          value = 0
        }
        let mut is_bigint = false
        if self.peek() == Some('n') {
          is_bigint = true
          let _ = self.advance()
        }
        if is_bigint {
          return Number(value.to_double())
        } else {
          return Int(value)
        }
      }
      Some('o') | Some('O') => {
        let _ = self.advance()
        let _ = self.advance()
        let mut value = 0
        let mut has_digit = false
        while true {
          match self.peek() {
            Some('_') => {
              let _ = self.advance()
            }
            Some('0') => {
              let _ = self.advance()
              value = value * 8 + 0
              has_digit = true
            }
            Some('1') => {
              let _ = self.advance()
              value = value * 8 + 1
              has_digit = true
            }
            Some('2') => {
              let _ = self.advance()
              value = value * 8 + 2
              has_digit = true
            }
            Some('3') => {
              let _ = self.advance()
              value = value * 8 + 3
              has_digit = true
            }
            Some('4') => {
              let _ = self.advance()
              value = value * 8 + 4
              has_digit = true
            }
            Some('5') => {
              let _ = self.advance()
              value = value * 8 + 5
              has_digit = true
            }
            Some('6') => {
              let _ = self.advance()
              value = value * 8 + 6
              has_digit = true
            }
            Some('7') => {
              let _ = self.advance()
              value = value * 8 + 7
              has_digit = true
            }
            _ => break
          }
        }
        if not(has_digit) {
          value = 0
        }
        let mut is_bigint = false
        if self.peek() == Some('n') {
          is_bigint = true
          let _ = self.advance()
        }
        if is_bigint {
          return Number(value.to_double())
        } else {
          return Int(value)
        }
      }
      _ => ()
    }
  }
  let mut has_dot = false
  let mut has_exp = false
  let mut is_bigint = false
  let mut has_sep = false
  while true {
    match self.peek() {
      Some(c) =>
        if c >= '0' && c <= '9' {
          let _ = self.advance()

        } else if c == '_' {
          has_sep = true
          let _ = self.advance()
        } else if c == '.' && not(has_dot) && not(has_exp) {
          has_dot = true
          let _ = self.advance()

        } else if (c == 'e' || c == 'E') && not(has_exp) {
          has_exp = true
          let _ = self.advance()
          match self.peek() {
            Some('+') | Some('-') => {
              let _ = self.advance()

            }
            _ => ()
          }
        } else {
          break
        }
      None => break
    }
  }
  if self.peek() == Some('n') {
    is_bigint = true
    let _ = self.advance()
  }
  let raw =
    if is_bigint {
      let end = if self.pos > start { self.pos - 1 } else { self.pos }
      try { self.src[start:end].to_string() } catch { _ => "" }
    } else {
      try { self.src[start:self.pos].to_string() } catch { _ => "" }
    }
  let s =
    if has_sep {
      let cleaned = StringBuilder::new()
      for ch in raw {
        if ch == '_' {
          continue
        }
        cleaned.write_char(ch)
      }
      cleaned.to_string()
    } else {
      raw
    }
  if has_dot || has_exp || is_bigint {
    // Double
    try {
      let d = @strconv.parse_double(s)
      Number(d)
    } catch {
      _ => Number(0.0)
    }
  } else {
    // Int
    try {
      let i = @strconv.parse_int(s)
      Int(i)
    } catch {
      _ => Int(0)
    }
  }
}

///|
// / /
fn Lexer::scan_ident(self : Lexer) -> TokenKind {
  let buf = StringBuilder::new()
  while true {
    match self.peek() {
      Some(c) =>
        if (c >= 'a' && c <= 'z') ||
          (c >= 'A' && c <= 'Z') ||
          (c >= '0' && c <= '9') ||
          c == '_' ||
          c == '$' {
          let _ = self.advance()
          buf.write_char(c)
        } else if c == '\\' {
          let _ = self.advance()
          match self.peek() {
            Some('u') => {
              let _ = self.advance()
              let mut code = 0
              let mut ok = true
              let mut digits = 0
              if self.peek() == Some('{') {
                let _ = self.advance()
                while true {
                  match self.peek() {
                    Some('}') => {
                      let _ = self.advance()
                      break
                    }
                    Some(_) =>
                      match self.read_hex_digit() {
                        Some(d) => {
                          code = code * 16 + d
                          digits = digits + 1
                        }
                        None => {
                          ok = false
                          break
                        }
                      }
                    None => {
                      ok = false
                      break
                    }
                  }
                }
              } else {
                for _ in 0..<4 {
                  match self.read_hex_digit() {
                    Some(d) => {
                      code = code * 16 + d
                      digits = digits + 1
                    }
                    None => {
                      ok = false
                      break
                    }
                  }
                }
              }
              if ok && digits > 0 {
                write_codepoint(buf, code)
              } else {
                buf.write_char('u')
              }
            }
            _ => break
          }
        } else {
          break
        }
      None => break
    }
  }
  let s = buf.to_string()
  if s == "function" {
    Function
  } else if s == "class" {
    Class
  } else if s == "extends" {
    Extends
  } else if s == "var" {
    Var
  } else if s == "let" {
    Let
  } else if s == "const" {
    Const
  } else if s == "return" {
    Return
  } else if s == "if" {
    If
  } else if s == "else" {
    Else
  } else if s == "switch" {
    Switch
  } else if s == "case" {
    Case
  } else if s == "default" {
    Default
  } else if s == "while" {
    While
  } else if s == "do" {
    Do
  } else if s == "for" {
    For
  } else if s == "break" {
    Break
  } else if s == "continue" {
    Continue
  } else if s == "try" {
    Try
  } else if s == "catch" {
    Catch
  } else if s == "finally" {
    Finally
  } else if s == "throw" {
    Throw
  } else if s == "yield" {
    Yield
  } else if s == "true" {
    Bool(true)
  } else if s == "false" {
    Bool(false)
  } else if s == "typeof" {
    Typeof
  } else if s == "delete" {
    Delete
  } else if s == "null" {
    Null
  } else if s == "number" {
    NumberType
  } else if s == "boolean" {
    BooleanType
  } else if s == "void" {
    VoidType
  } else if s == "int" {
    IntType
  } else if s == "string" {
    StringType
  } else if s == "new" {
    New
  } else if s == "interface" {
    Interface
  } else if s == "type" {
    Type
  } else if s == "of" {
    Of
  } else if s == "in" {
    In
  } else if s == "declare" {
    Declare
  } else if s == "instanceof" {
    Instanceof
  } else {
    Ident(s)
  }
}

///|
// / stringliteral
fn Lexer::scan_string(self : Lexer, quote : Char) -> TokenKind {
  let buf = StringBuilder::new()
  while true {
    match self.peek() {
      None => break // (errorsimplehandle)
      Some(c) =>
        if c == quote {
          let _ = self.advance()
          break
        } else if c == '\\' {

          let _ = self.advance()
          match self.peek() {
            Some('n') => {
              let _ = self.advance()
              buf.write_char('\n')
            }
            Some('t') => {
              let _ = self.advance()
              buf.write_char('\t')
            }
            Some('r') => {
              let _ = self.advance()
              buf.write_char('\r')
            }
            Some('b') => {
              let _ = self.advance()
              buf.write_char('\u0008'.to_int().unsafe_to_char())
            }
            Some('f') => {
              let _ = self.advance()
              buf.write_char('\u000c'.to_int().unsafe_to_char())
            }
            Some('v') => {
              let _ = self.advance()
              buf.write_char('\u000b'.to_int().unsafe_to_char())
            }
            Some('0') => {
              let _ = self.advance()
              buf.write_char('\u0000'.to_int().unsafe_to_char())
            }
            Some('x') => {
              let _ = self.advance()
              let mut code = 0
              let mut ok = true
              for _ in 0..<2 {
                match self.read_hex_digit() {
                  Some(d) => code = code * 16 + d
                  None => {
                    ok = false
                    break
                  }
                }
              }
              if ok {
                write_codepoint(buf, code)
              } else {
                buf.write_char('x')
              }
            }
            Some('u') => {
              let _ = self.advance()
              let mut code = 0
              let mut ok = true
              for _ in 0..<4 {
                match self.read_hex_digit() {
                  Some(d) => code = code * 16 + d
                  None => {
                    ok = false
                    break
                  }
                }
              }
              if ok {
                write_codepoint(buf, code)
              } else {
                buf.write_char('u')
              }
            }
            Some('\\') => {
              let _ = self.advance()
              buf.write_char('\\')
            }
            Some('\'') => {
              let _ = self.advance()
              buf.write_char('\'')
            }
            Some('"') => {
              let _ = self.advance()
              buf.write_char('"')
            }
            Some(other) => {
              let _ = self.advance()
              buf.write_char(other)
            }
            None => break
          }
        } else {
          let _ = self.advance()
          buf.write_char(c)
        }
    }
  }
  Str(buf.to_string())
}

///|
// / literal (`...`)
fn Lexer::scan_template(self : Lexer) -> TokenKind {
  let buf = StringBuilder::new()
  while true {
    match self.peek() {
      None => break
      Some(c) =>
        if c == '`' {
          let _ = self.advance()
          break
        } else if c == '$' && self.peek_next() == Some('{') {
          let _ = self.advance()
          let _ = self.advance()
          self.skip_template_expr()
        } else if c == '\\' {
          let _ = self.advance()
          match self.peek() {
            Some('n') => {
              let _ = self.advance()
              buf.write_char('\n')
            }
            Some('t') => {
              let _ = self.advance()
              buf.write_char('\t')
            }
            Some('r') => {
              let _ = self.advance()
              buf.write_char('\r')
            }
            Some('b') => {
              let _ = self.advance()
              buf.write_char('\u0008'.to_int().unsafe_to_char())
            }
            Some('f') => {
              let _ = self.advance()
              buf.write_char('\u000c'.to_int().unsafe_to_char())
            }
            Some('v') => {
              let _ = self.advance()
              buf.write_char('\u000b'.to_int().unsafe_to_char())
            }
            Some('0') => {
              let _ = self.advance()
              buf.write_char('\u0000'.to_int().unsafe_to_char())
            }
            Some('x') => {
              let _ = self.advance()
              let mut code = 0
              let mut ok = true
              for _ in 0..<2 {
                match self.read_hex_digit() {
                  Some(d) => code = code * 16 + d
                  None => {
                    ok = false
                    break
                  }
                }
              }
              if ok {
                write_codepoint(buf, code)
              } else {
                buf.write_char('x')
              }
            }
            Some('u') => {
              let _ = self.advance()
              let mut code = 0
              let mut ok = true
              for _ in 0..<4 {
                match self.read_hex_digit() {
                  Some(d) => code = code * 16 + d
                  None => {
                    ok = false
                    break
                  }
                }
              }
              if ok {
                write_codepoint(buf, code)
              } else {
                buf.write_char('u')
              }
            }
            Some('\\') => {
              let _ = self.advance()
              buf.write_char('\\')
            }
            Some('`') => {
              let _ = self.advance()
              buf.write_char('`')
            }
            Some(other) => {
              let _ = self.advance()
              buf.write_char(other)
            }
            None => break
          }
        } else {
          let _ = self.advance()
          buf.write_char(c)
        }
    }
  }
  Str(buf.to_string())
}

///|
// / ${ ... }
fn Lexer::skip_template_expr(self : Lexer) -> Unit {
  let mut depth = 1
  while depth > 0 {
    match self.peek() {
      None => break
      Some(c) => {
        let _ = self.advance()
        match c {
          '{' => depth += 1
          '}' => depth -= 1
          '\'' | '"' => self.skip_string_body(c)
          '`' => {
            let _ = self.scan_template()
          }
          _ => ()
        }
      }
    }
  }
}

///|
// / string()
fn Lexer::skip_string_body(self : Lexer, quote : Char) -> Unit {
  while true {
    match self.peek() {
      None => break
      Some(c) => {
        let _ = self.advance()
        if c == quote {
          break
        }
        if c == '\\' {
          let _ = self.advance()
        }
      }
    }
  }
}

///|
// / literal (/pattern/flags)
fn Lexer::scan_regex(self : Lexer) -> TokenKind {
  let buf = StringBuilder::new()
  let mut in_class = false
  let mut escaped = false
  while true {
    match self.peek() {
      None => break
      Some(c) => {
        let _ = self.advance()
        if escaped {
          buf.write_char(c)
          escaped = false
          continue
        }
        if c == '\\' {
          buf.write_char(c)
          escaped = true
          continue
        }
        if c == '[' {
          in_class = true
        } else if c == ']' {
          in_class = false
        }
        if c == '/' && not(in_class) {
          break
        }
        buf.write_char(c)
      }
    }
  }
  let flags = StringBuilder::new()
  while true {
    match self.peek() {
      Some(c) =>
        if (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') {
          let _ = self.advance()
          flags.write_char(c)
        } else {
          break
        }
      None => break
    }
  }
  Regex(buf.to_string(), flags.to_string())
}

///|
// / expression
fn token_can_end_expr(kind : TokenKind) -> Bool {
  match kind {
    Number(_)
    | Int(_)
    | Bool(_)
    | Str(_)
    | Regex(_, _)
    | Ident(_)
    | Null
    | RParen
    | RBracket
    | RBrace
    | PlusPlus
    | MinusMinus => true
    _ => false
  }
}

///|
// / get
pub fn Lexer::next_token(self : Lexer) -> Token {
  self.skip_whitespace()
  let pos = self.pos
  match self.advance() {
    None => { kind: Eof, pos }
    Some(c) => {
      let kind : TokenKind = match c {

        '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' => {
          self.pos -= 1
          self.scan_number()
        }
        // /
        'a'
        | 'b'
        | 'c'
        | 'd'
        | 'e'
        | 'f'
        | 'g'
        | 'h'
        | 'i'
        | 'j'
        | 'k'
        | 'l'
        | 'm'
        | 'n'
        | 'o'
        | 'p'
        | 'q'
        | 'r'
        | 's'
        | 't'
        | 'u'
        | 'v'
        | 'w'
        | 'x'
        | 'y'
        | 'z'
        | 'A'
        | 'B'
        | 'C'
        | 'D'
        | 'E'
        | 'F'
        | 'G'
        | 'H'
        | 'I'
        | 'J'
        | 'K'
        | 'L'
        | 'M'
        | 'N'
        | 'O'
        | 'P'
        | 'Q'
        | 'R'
        | 'S'
        | 'T'
        | 'U'
        | 'V'
        | 'W'
        | 'X'
        | 'Y'
        | 'Z'
        | '_'
        | '$' => {
          self.pos -= 1
          self.scan_ident()
        }
        '\\' =>
          match self.peek() {
            Some('u') => {
              self.pos -= 1
              self.scan_ident()
            }
            _ => {
              // invalid start, treat as identifier fallback
              self.pos -= 1
              self.scan_ident()
            }
          }
        // operator
        '+' =>
          match self.peek() {
            Some('+') => {
              let _ = self.advance()
              PlusPlus
            }
            Some('=') => {
              let _ = self.advance()
              PlusEq
            }
            _ => Plus
          }
        '-' =>
          match self.peek() {
            Some('-') => {
              let _ = self.advance()
              MinusMinus
            }
            Some('=') => {
              let _ = self.advance()
              MinusEq
            }
            _ => Minus
          }
        '*' =>
          match self.peek() {
            Some('*') => {
              let _ = self.advance()
              match self.peek() {
                Some('=') => {
                  let _ = self.advance()
                  StarStarEq
                }
                _ => StarStar
              }
            }
            Some('=') => {
              let _ = self.advance()
              StarEq
            }
            _ => Star
          }
        '/' =>
          match self.peek() {
            Some('=') => {
              let _ = self.advance()
              SlashEq
            }
            _ =>
              if self.allow_regex {
                self.scan_regex()
              } else {
                Slash
              }
          }
        '%' =>
          match self.peek() {
            Some('=') => {
              let _ = self.advance()
              PercentEq
            }
            _ => Percent
          }
        '?' => Question
        '=' =>
          match self.peek() {
            Some('=') =>
              match self.peek_next() {
                Some('=') => {
                  let _ = self.advance()
                  let _ = self.advance()
                  EqEqEq
                }
                _ => {
                  let _ = self.advance()
                  EqEq
                }
              }
            Some('>') => {
              let _ = self.advance()
              Arrow
            }
            _ => Eq
          }
        '!' =>
          match self.peek() {
            Some('=') =>
              match self.peek_next() {
                Some('=') => {
                  let _ = self.advance()
                  let _ = self.advance()
                  BangEqEq
                }
                _ => {
                  let _ = self.advance()
                  BangEq
                }
              }
            _ => Bang
          }
        '<' =>
          match self.peek() {
            Some('=') => {
              let _ = self.advance()
              Le
            }
            Some('<') => {
              let _ = self.advance()
              match self.peek() {
                Some('=') => {
                  let _ = self.advance()
                  LtLtEq
                }
                _ => LtLt
              }
            }
            _ => Lt
          }
        '>' =>
          match self.peek() {
            Some('=') => {
              let _ = self.advance()
              Ge
            }
            Some('>') => {
              let _ = self.advance()
              match self.peek() {
                Some('>') => {
                  let _ = self.advance()
                  match self.peek() {
                    Some('=') => {
                      let _ = self.advance()
                      GtGtGtEq
                    }
                    _ => GtGtGt
                  }
                }
                Some('=') => {
                  let _ = self.advance()
                  GtGtEq
                }
                _ => GtGt
              }
            }
            _ => Gt
          }
        '&' =>
          match self.peek() {
            Some('&') => {
              let _ = self.advance()
              AmpAmp
            }
            Some('=') => {
              let _ = self.advance()
              AmpEq
            }
            _ => Amp
          }
        '|' =>
          match self.peek() {
            Some('|') => {
              let _ = self.advance()
              PipePipe
            }
            Some('=') => {
              let _ = self.advance()
              PipeEq
            }
            _ => Pipe
          }
        '^' =>
          match self.peek() {
            Some('=') => {
              let _ = self.advance()
              CaretEq
            }
            _ => Caret
          }

        '(' => LParen
        ')' => RParen
        '{' => LBrace
        '}' => RBrace
        '[' => LBracket
        ']' => RBracket
        ',' => Comma
        ':' => Colon
        ';' => Semicolon
        '.' =>
          match self.peek() {
            Some('0'..='9') => {
              self.pos -= 1
              self.scan_number()
            }
            Some('.') =>
              match self.peek_next() {
                Some('.') => {
                  let _ = self.advance()
                  let _ = self.advance()
                  Ellipsis
                }
                _ => Dot
              }
            _ => Dot
          }
        '"' | '\'' => {
          // stringliteral
          let quote = c
          self.scan_string(quote)
        }
        '`' => {
          // literal
          self.scan_template()
        }
        _ => Eof // statement
      }
      self.allow_regex = not(token_can_end_expr(kind))
      { kind, pos }
    }
  }
}

///|
// / get
pub fn Lexer::tokenize(self : Lexer) -> Array[Token] {
  let len = self.src.length()
  let tokens : Array[Token] =
    if len >= 1024 {
      let cap = (len / 2) + 4
      Array::new(capacity=cap)
    } else {
      []
    }
  while true {
    let tok = self.next_token()
    tokens.push(tok)
    if tok.kind == Eof {
      break
    }
  }
  tokens
}
