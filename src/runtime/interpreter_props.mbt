///|
// / get
fn JSInterpreter::get_proto(_self : JSInterpreter, value : JSValue) -> JSValue? {
  match value {
    Object(_) | Function(_) | Array(_) =>
      if _self.is_proxy(value) {
        let proto_val = _self.proxy_get_prototype_of(value)
        match _self.peek_error() {
          Some(_) => None
          None =>
            match proto_val {
              Object(_) | Function(_) | Array(_) | Null => Some(proto_val)
              _ => None
            }
        }
      } else {
        match value {
          Object(map) => map.prototype
          Function(closure) => closure.object_proto
          Array(arr) => arr.prototype
          _ => None
        }
      }
    _ => None
  }
}

///|
fn JSInterpreter::normalize_prop_key(
  _self : JSInterpreter,
  key : String,
) -> String {
  if key == "Symbol(Symbol.iterator)" {
    "@@iterator"
  } else {
    key
  }
}

///|
fn JSInterpreter::proxy_key_value(
  _self : JSInterpreter,
  key : String,
) -> JSValue {
  if key == "@@iterator" {
    String("Symbol(Symbol.iterator)")
  } else {
    String(key)
  }
}

///|
fn JSInterpreter::is_proxy(_self : JSInterpreter, value : JSValue) -> Bool {
  match value {
    Object(_) | Function(_) | Array(_) =>
      js_has_prop(value, "__proxy_target") &&
      js_has_prop(value, "__proxy_handler")
    _ => false
  }
}

///|
fn JSInterpreter::proxy_target(
  _self : JSInterpreter,
  proxy : JSValue,
) -> JSValue {
  js_get_prop(proxy, "__proxy_target")
}

///|
fn JSInterpreter::proxy_handler(
  _self : JSInterpreter,
  proxy : JSValue,
) -> JSValue {
  js_get_prop(proxy, "__proxy_handler")
}

///|
fn JSInterpreter::new_proxy(
  self : JSInterpreter,
  target : JSValue,
  handler : JSValue,
) -> JSValue {
  match target {
    Object(_) | Function(_) | Array(_) => ()
    _ => {
      let _ = self.set_error_kind("TypeError", "Proxy target is not an object")
      return Undefined
    }
  }
  match handler {
    Object(_) | Function(_) | Array(_) => ()
    _ => {
      let _ = self.set_error_kind("TypeError", "Proxy handler is not an object")
      return Undefined
    }
  }
  let proxy = self.new_object()
  let _ = js_set_prop(proxy, "__proxy_target", target)
  let _ = js_set_prop(proxy, "__proxy_handler", handler)
  proxy
}

///|
fn JSInterpreter::get_proxy_trap(
  self : JSInterpreter,
  handler : JSValue,
  name : String,
) -> JSValue? {
  let trap = self.get_prop_value(handler, name)
  match self.peek_error() {
    Some(_) => return None
    None => ()
  }
  match trap {
    Undefined | Null => None
    _ =>
      if not(self.is_callable(trap)) {
        let _ = self.set_error_kind("TypeError", "Proxy trap is not callable")
        None
      } else {
        Some(trap)
      }
  }
}

///|
fn JSInterpreter::proxy_get(
  self : JSInterpreter,
  proxy : JSValue,
  key : String,
  receiver : JSValue,
) -> JSValue {
  let handler = self.proxy_handler(proxy)
  match handler {
    Null | Undefined =>
      return self.set_error_kind(
        "TypeError", "Cannot perform operation on a revoked Proxy",
      )
    _ => ()
  }
  let target = self.proxy_target(proxy)
  let norm_key = self.normalize_prop_key(key)
  let key_val = self.proxy_key_value(norm_key)
  match self.get_proxy_trap(handler, "get") {
    Some(trap) => self.call_function(trap, handler, [target, key_val, receiver])
    None => self.get_prop_value_with_receiver(target, receiver, norm_key)
  }
}

///|
fn JSInterpreter::proxy_set(
  self : JSInterpreter,
  proxy : JSValue,
  key : String,
  value : JSValue,
  receiver : JSValue,
) -> Bool {
  let handler = self.proxy_handler(proxy)
  match handler {
    Null | Undefined => {
      let _ = self.set_error_kind(
        "TypeError", "Cannot perform operation on a revoked Proxy",
      )
      return false
    }
    _ => ()
  }
  let target = self.proxy_target(proxy)
  let norm_key = self.normalize_prop_key(key)
  let key_val = self.proxy_key_value(norm_key)
  match self.get_proxy_trap(handler, "set") {
    Some(trap) => {
      let result = self.call_function(trap, handler, [
        target, key_val, value, receiver,
      ])
      match self.peek_error() {
        Some(_) => false
        None => result.to_boolean()
      }
    }
    None => {
      self.set_prop_value(target, norm_key, value)
      match self.peek_error() {
        Some(_) => false
        None => true
      }
    }
  }
}

///|
fn JSInterpreter::proxy_has(
  self : JSInterpreter,
  proxy : JSValue,
  key : String,
) -> Bool {
  let handler = self.proxy_handler(proxy)
  match handler {
    Null | Undefined => {
      let _ = self.set_error_kind(
        "TypeError", "Cannot perform operation on a revoked Proxy",
      )
      return false
    }
    _ => ()
  }
  let target = self.proxy_target(proxy)
  let norm_key = self.normalize_prop_key(key)
  let key_val = self.proxy_key_value(norm_key)
  match self.get_proxy_trap(handler, "has") {
    Some(trap) => {
      let result = self.call_function(trap, handler, [target, key_val])
      match self.peek_error() {
        Some(_) => false
        None => result.to_boolean()
      }
    }
    None => js_has_prop(target, norm_key)
  }
}

///|
fn JSInterpreter::proxy_get_own_property_descriptor(
  self : JSInterpreter,
  proxy : JSValue,
  key : String,
) -> JSValue {
  let handler = self.proxy_handler(proxy)
  match handler {
    Null | Undefined =>
      return self.set_error_kind(
        "TypeError", "Cannot perform operation on a revoked Proxy",
      )
    _ => ()
  }
  let target = self.proxy_target(proxy)
  let norm_key = self.normalize_prop_key(key)
  let key_val = self.proxy_key_value(norm_key)
  match self.get_proxy_trap(handler, "getOwnPropertyDescriptor") {
    Some(trap) => self.call_function(trap, handler, [target, key_val])
    None =>
      self.call_native("Object.getOwnPropertyDescriptor", Undefined, [
        target,
        String(norm_key),
      ])
  }
}

///|
fn JSInterpreter::proxy_define_property(
  self : JSInterpreter,
  proxy : JSValue,
  key : String,
  desc : JSValue,
) -> JSValue {
  let handler = self.proxy_handler(proxy)
  match handler {
    Null | Undefined =>
      return self.set_error_kind(
        "TypeError", "Cannot perform operation on a revoked Proxy",
      )
    _ => ()
  }
  let target = self.proxy_target(proxy)
  let norm_key = self.normalize_prop_key(key)
  let key_val = self.proxy_key_value(norm_key)
  match self.get_proxy_trap(handler, "defineProperty") {
    Some(trap) => {
      let result = self.call_function(trap, handler, [target, key_val, desc])
      match self.peek_error() {
        Some(err) => err
        None => result
      }
    }
    None => self.define_property(target, norm_key, desc)
  }
}

///|
fn JSInterpreter::proxy_get_prototype_of(
  self : JSInterpreter,
  proxy : JSValue,
) -> JSValue {
  let handler = self.proxy_handler(proxy)
  match handler {
    Null | Undefined =>
      return self.set_error_kind(
        "TypeError", "Cannot perform operation on a revoked Proxy",
      )
    _ => ()
  }
  let target = self.proxy_target(proxy)
  match self.get_proxy_trap(handler, "getPrototypeOf") {
    Some(trap) => self.call_function(trap, handler, [target])
    None => {
      let proto = match target {
        Object(map) =>
          match map.prototype {
            Some(p) => p
            None => Null
          }
        Function(closure) =>
          match closure.object_proto {
            Some(p) => p
            None => Null
          }
        Array(arr) =>
          match arr.prototype {
            Some(p) => p
            None => Null
          }
        _ => Null
      }
      proto
    }
  }
}

///|
// / propertyget()
pub fn JSInterpreter::get_prop_value(
  self : JSInterpreter,
  obj : JSValue,
  key : String,
) -> JSValue {
  self.get_prop_value_with_receiver(obj, obj, key)
}

///|
fn JSInterpreter::set_prop_value(
  self : JSInterpreter,
  obj : JSValue,
  key : String,
  value : JSValue,
) -> Unit {
  let key = self.normalize_prop_key(key)
  if self.is_proxy(obj) {
    let _ = self.proxy_set(obj, key, value, obj)
    return
  }
  match obj {
    Function(closure) =>
      for prop in closure.props {
        if prop.key == key {
          match prop.set {
            Some(setter) => {
              let _ = self.call_function(setter, obj, [value])
              return
            }
            None => {
              let _ = js_set_prop(obj, key, value)
              return
            }
          }
        }
      }
    Object(map) =>
      for prop in map.props {
        if prop.key == key {
          match prop.set {
            Some(setter) => {
              let _ = self.call_function(setter, obj, [value])
              return
            }
            None => {
              let _ = js_set_prop(obj, key, value)
              return
            }
          }
        }
      }
    Array(arr) =>
      for prop in arr.props {
        if prop.key == key {
          match prop.set {
            Some(setter) => {
              let _ = self.call_function(setter, obj, [value])
              return
            }
            None => {
              let _ = js_set_prop(obj, key, value)
              return
            }
          }
        }
      }
    _ => ()
  }
  let _ = js_set_prop(obj, key, value)

}

///|
// / propertyget
fn JSInterpreter::get_prop_value_with_receiver(
  self : JSInterpreter,
  target : JSValue,
  receiver : JSValue,
  key : String,
) -> JSValue {
  let key = self.normalize_prop_key(key)
  if self.is_proxy(target) {
    return self.proxy_get(target, key, receiver)
  }
  match target {
    Undefined | Null => {
      let _ = self.set_error_kind(
        "TypeError", "Cannot read properties of null or undefined",
      )
      return Undefined
    }
    _ => ()
  }
  match target {
    Function(closure) => {
      for prop in closure.props {
        if prop.key == key {
          return self.eval_prop_value(receiver, prop)
        }
      }
      match closure.object_proto {
        Some(proto) => self.get_prop_value_with_receiver(proto, receiver, key)
        None => Undefined
      }
    }
    Object(map) => {
      for prop in map.props {
        if prop.key == key {
          return self.eval_prop_value(receiver, prop)
        }
      }
      match map.prototype {
        Some(proto) => self.get_prop_value_with_receiver(proto, receiver, key)
        None => Undefined
      }
    }
    Array(arr) =>
      if key == "length" {
        Number(arr.length.to_double())
      } else {
        let idx = @strconv.parse_int(key) catch { _ => -1 }
        if idx >= 0 && idx < arr.items.length() && arr.present[idx] {
          arr.items[idx]
        } else {
          for prop in arr.props {
            if prop.key == key {
              return self.eval_prop_value(receiver, prop)
            }
          }
          if key == "constructor" {
            self.global_env.get("Array")
          } else {
            match arr.prototype {
              Some(proto) =>
                self.get_prop_value_with_receiver(proto, receiver, key)
              None => Undefined
            }
          }
        }
      }
    String(s) =>
      if key == "length" {
        Number(s.length().to_double())
      } else {
        let idx = @strconv.parse_int(key) catch { _ => -1 }
        if idx >= 0 && idx < s.length() {
          String(s[idx:idx + 1].to_string() catch { _ => "" })
        } else {
          Undefined
        }
      }
    _ => Undefined
  }
}

///|
// / property
fn JSInterpreter::eval_prop_value(
  self : JSInterpreter,
  receiver : JSValue,
  prop : JSProp,
) -> JSValue {
  match prop.get {
    Some(getter) => self.call_function(getter, receiver, [])
    None => prop.value
  }
}

///|
// / own property check
fn JSInterpreter::has_own_prop(
  _self : JSInterpreter,
  obj : JSValue,
  key : String,
) -> Bool {
  let key = _self.normalize_prop_key(key)
  if _self.is_proxy(obj) {
    return _self.proxy_has(obj, key)
  }
  match obj {
    Function(closure) => {
      for prop in closure.props {
        if prop.key == key {
          return true
        }
      }
      false
    }
    Object(map) => {
      for prop in map.props {
        if prop.key == key {
          return true
        }
      }
      false
    }
    Array(arr) =>
      if key == "length" {
        true
      } else {
        let idx = @strconv.parse_int(key) catch { _ => -1 }
        if idx >= 0 && idx < arr.items.length() && arr.present[idx] {
          true
        } else {
          let mut found = false
          for prop in arr.props {
            if prop.key == key {
              found = true
              break
            }
          }
          found
        }
      }
    String(s) =>
      if key == "length" {
        true
      } else {
        let idx = @strconv.parse_int(key) catch { _ => -1 }
        idx >= 0 && idx < s.length()
      }
    _ => false
  }
}

///|
// / enumerable check
fn JSInterpreter::is_enumerable(
  _self : JSInterpreter,
  obj : JSValue,
  key : String,
) -> Bool {
  match obj {
    Function(closure) => {
      for prop in closure.props {
        if prop.key == key {
          return prop.enumerable
        }
      }
      false
    }
    Object(map) => {
      for prop in map.props {
        if prop.key == key {
          return prop.enumerable
        }
      }
      false
    }
    Array(arr) =>
      if key == "length" {
        false
      } else {
        let idx = @strconv.parse_int(key) catch { _ => -1 }
        if idx >= 0 && idx < arr.items.length() {
          true
        } else {
          let mut found = false
          for prop in arr.props {
            if prop.key == key {
              found = prop.enumerable
              break
            }
          }
          found
        }
      }
    String(s) =>
      if key == "length" {
        false
      } else {
        let idx = @strconv.parse_int(key) catch { _ => -1 }
        idx >= 0 && idx < s.length()
      }
    _ => false
  }
}

///|
// / Instanceof check
fn JSInterpreter::ordinary_has_instance(
  self : JSInterpreter,
  ctor : JSValue,
  obj : JSValue,
) -> Bool {
  let target = match ctor {
    Function(closure) =>
      match closure.body {
        Bound(bound_target, _, _) => bound_target
        _ => ctor
      }
    _ => ctor
  }
  if not(self.is_callable(target)) {
    return false
  }
  match obj {
    Object(_) | Array(_) | Function(_) => ()
    _ => return false
  }
  let proto = js_get_prop(target, "prototype")
  match proto {
    Object(_) | Function(_) => ()
    _ => return false
  }
  let mut cur = self.get_proto(obj)
  while cur is Some(p) {
    match js_strict_eq(p, proto) {
      Bool(true) => return true
      _ => ()
    }
    cur = self.get_proto(p)
  }
  false
}

///|
// / new-target generate
fn JSInterpreter::construct_with(
  self : JSInterpreter,
  ctor : JSValue,
  new_target : JSValue,
  args : Array[JSValue],
) -> JSValue {
  if not(self.is_constructor(ctor)) || not(self.is_constructor(new_target)) {
    return self.set_error_kind("TypeError", "not a constructor")
  }
  match ctor {
    Function(closure) =>
      match closure.body {
        Native(name) if name == "Promise" => {
          let executor = if args.length() > 0 { args[0] } else { Undefined }
          if not(self.is_callable(executor)) {
            return self.set_error_kind(
              "TypeError", "Promise resolver is not a function",
            )
          }
        }
        _ => ()
      }
    _ => ()
  }
  match ctor {
    Function(closure) =>
      match closure.body {
        Bound(bound_target, _bound_this, bound_args) => {
          let merged : Array[JSValue] = []
          for item in bound_args {
            merged.push(item)
          }
          for item in args {
            merged.push(item)
          }
          let next_new_target = match js_strict_eq(new_target, ctor) {
            Bool(true) => bound_target
            _ => new_target
          }
          return self.construct_with(bound_target, next_new_target, merged)
        }
        _ => ()
      }
    _ => ()
  }
  let proto_val = self.get_prop_value(new_target, "prototype")
  match self.peek_error() {
    Some(err) => return err
    None => ()
  }
  let mut proto = proto_val
  match proto {
    Object(_) | Function(_) => ()
    _ => {
      let fallback = js_get_prop(new_target, "__default_proto__")
      match fallback {
        Object(_) | Function(_) => proto = fallback
        _ => {
          let fallback_ctor = js_get_prop(ctor, "__default_proto__")
          match fallback_ctor {
            Object(_) | Function(_) => proto = fallback_ctor
            _ => ()
          }
        }
      }
    }
  }
  let instance = match proto {
    Object(_) | Function(_) => js_new_object_with_proto(Some(proto))
    _ => self.new_object()
  }
  let result = self.call_function(ctor, instance, args, new_target~)
  match result {
    Object(_) | Array(_) | Function(_) => result
    _ => instance
  }
}

///|
// / object
fn JSInterpreter::wrap_primitive(
  self : JSInterpreter,
  env : JSEnv,
  value : JSValue,
) -> JSValue {
  match value {
    Bool(_) => {
      let ctor = env.get("Boolean")
      let proto = js_get_prop(ctor, "prototype")
      let obj = match proto {
        Object(_) | Function(_) => js_new_object_with_proto(Some(proto))
        _ => self.new_object()
      }
      let _ = js_set_prop(obj, "value", value)
      obj
    }
    Number(_) => {
      let ctor = env.get("Number")
      let proto = js_get_prop(ctor, "prototype")
      let obj = match proto {
        Object(_) | Function(_) => js_new_object_with_proto(Some(proto))
        _ => self.new_object()
      }
      let _ = js_set_prop(obj, "value", value)
      obj
    }
    String(_) => {
      let ctor = env.get("String")
      let proto = js_get_prop(ctor, "prototype")
      let obj = match proto {
        Object(_) | Function(_) => js_new_object_with_proto(Some(proto))
        _ => self.new_object()
      }
      let _ = js_set_prop(obj, "value", value)
      obj
    }
    _ => value
  }
}

///|
// / ToPrimitive(+) (Object value / toString )
fn JSInterpreter::to_primitive_for_add(
  self : JSInterpreter,
  value : JSValue,
) -> JSValue {
  match value {
    Object(_) | Array(_) | Function(_) => String(self.to_string_value(value))
    _ => value
  }
}

///|
// / JS ToString (Object toString )
fn JSInterpreter::to_string_value(
  self : JSInterpreter,
  value : JSValue,
) -> String {
  match value {
    String(s) =>
      if s.has_prefix("Symbol(") {
        let _ = self.set_error_kind(
          "TypeError", "Cannot convert Symbol to string",
        )
        ""
      } else {
        s
      }
    Object(_) | Array(_) | Function(_) => {
      let to_prim = js_get_prop(value, "@@toPrimitive")
      if self.is_callable(to_prim) {
        let res = self.call_function(to_prim, value, [String("string")])
        match res {
          Object(_) | Array(_) | Function(_) => {
            let _ = self.set_error_kind(
              "TypeError", "Cannot convert object to primitive value",
            )
            return ""
          }
          _ => return res.to_js_string()
        }
      } else if not(to_prim.is_undefined()) {
        let _ = self.set_error_kind(
          "TypeError", "Cannot convert object to primitive value",
        )
        return ""
      }
      match js_get_prop(value, "__class") {
        String("BigInt") =>
          match js_get_prop(value, "value") {
            String(s) => return s
            _ => ()
          }
        _ => ()
      }
      let to_str = js_get_prop(value, "toString")
      if self.is_callable(to_str) {
        let res = self.call_function(to_str, value, [])
        match res {
          Object(_) | Array(_) | Function(_) => ()
          _ => return res.to_js_string()
        }
      }
      let value_of = js_get_prop(value, "valueOf")
      if self.is_callable(value_of) {
        let res = self.call_function(value_of, value, [])
        match res {
          Object(_) | Array(_) | Function(_) => ()
          _ => return res.to_js_string()
        }
      }
      value.to_js_string()
    }
    _ => value.to_js_string()
  }
}

///|
// / JS ToNumber (Object valueOf/toString)
fn JSInterpreter::to_number_value(
  self : JSInterpreter,
  value : JSValue,
) -> Double {
  match value {
    String(s) =>
      if s.has_prefix("Symbol(") {
        let _ = self.set_error_kind(
          "TypeError", "Cannot convert Symbol to number",
        )
        0.0
      } else {
        value.to_number()
      }
    Object(_) | Array(_) | Function(_) => {
      let value_of = js_get_prop(value, "valueOf")
      if self.is_callable(value_of) {
        let res = self.call_function(value_of, value, [])
        match res {
          Object(_) | Array(_) | Function(_) => ()
          _ => return res.to_number()
        }
      }
      let to_str = js_get_prop(value, "toString")
      if self.is_callable(to_str) {
        let res = self.call_function(to_str, value, [])
        match res {
          Object(_) | Array(_) | Function(_) => ()
          _ => return res.to_number()
        }
      }
      value.to_number()
    }
    _ => value.to_number()
  }
}

///|
// / JSON string escape
fn JSInterpreter::json_escape(_self : JSInterpreter, s : String) -> String {
  let sb = StringBuilder::new()
  for ch in s {
    match ch {
      '\"' => sb.write_string("\\\"")
      '\\' => sb.write_string("\\\\")
      '\n' => sb.write_string("\\n")
      '\r' => sb.write_string("\\r")
      '\t' => sb.write_string("\\t")
      _ => sb.write_char(ch)
    }
  }
  sb.to_string()
}

///|
// / JSON string unescape (minimal)
fn JSInterpreter::json_unescape(_self : JSInterpreter, s : String) -> String {
  let sb = StringBuilder::new()
  let mut i = 0
  let chars : Array[Char] = []
  for ch in s {
    chars.push(ch)
  }
  while i < chars.length() {
    let ch = chars[i]
    if ch == '\\' && i + 1 < chars.length() {
      let next = chars[i + 1]
      match next {
        '\"' => sb.write_char('\"')
        '\\' => sb.write_char('\\')
        'n' => sb.write_char('\n')
        'r' => sb.write_char('\r')
        't' => sb.write_char('\t')
        _ => sb.write_char(next)
      }
      i += 2
    } else {
      sb.write_char(ch)
      i += 1
    }
  }
  sb.to_string()
}

///|
// / JSON stringify (minimal)
fn JSInterpreter::json_stringify_value(
  self : JSInterpreter,
  value : JSValue,
  depth : Int,
  in_array : Bool,
) -> String? {
  self.tick()
  match self.peek_error() {
    Some(_) => return None
    None => ()
  }
  if depth > 5 {
    return Some("null")
  }
  match value {
    Undefined => if in_array { Some("null") } else { None }
    Function(_) => if in_array { Some("null") } else { None }
    Null => Some("null")
    Bool(b) => Some(if b { "true" } else { "false" })
    Number(n) =>
      if n.is_nan() || n.is_inf() {
        Some("null")
      } else {
        Some(n.to_string())
      }
    String(s) => Some("\"" + self.json_escape(s) + "\"")
    Array(arr) => {
      let parts : Array[String] = []
      let arr_val = JSValue::Array(arr)
      let len = arr.length
      for i in 0..<len {
        self.tick()
        match self.peek_error() {
          Some(_) => return None
          None => ()
        }
        let key = i.to_string()
        let elem = if js_has_prop(arr_val, key) {
          self.get_prop_value(arr_val, key)
        } else {
          Undefined
        }
        let elem_str = self.json_stringify_value(elem, depth + 1, true)
        match elem_str {
          Some(s) => parts.push(s)
          None => parts.push("null")
        }
      }
      Some("[" + parts.join(",") + "]")
    }
    Object(map) => {
      let keys : Array[String] = []
      for prop in map.props {
        if prop.enumerable {
          keys.push(prop.key)
        }
      }
      let parts : Array[String] = []
      for key in keys {
        self.tick()
        match self.peek_error() {
          Some(_) => return None
          None => ()
        }
        let value_str = self.json_stringify_value(
          self.get_prop_value(JSValue::Object(map), key),
          depth + 1,
          false,
        )
        match value_str {
          Some(s) => {
            let key_str = "\"" + self.json_escape(key) + "\""
            parts.push(key_str + ":" + s)
          }
          None => ()
        }
      }
      Some("{" + parts.join(",") + "}")
    }
    BreakSignal(_) | ContinueSignal(_) | Empty => None
  }
}
